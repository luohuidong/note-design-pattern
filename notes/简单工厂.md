# 简单工厂

简单工厂并不是设计模式，而是一种编程习惯。它的作用是将对象的创建和使用分离，将对象的创建交给一个工厂类来负责。

假设一个披萨店处理披萨订单的场景：

```ts
abstract class Pizza {
  /** 准备操作 */
  prepare() {}
  /** 烘烤操作 */
  bake() {}
  /** 裁剪操作 */
  cut() {}
  /** 打包操作 */
  box() {}
}

class CheesePizza extends Pizza {}
class GreekPizza extends Pizza {}
class PepperoniPizza extends Pizza {}

class PizzaStore {
  orderPizza(type: "cheese" | "greek" | "pepperoni") {
    let pizza!: Pizza;

    if (type === "cheese") {
      pizza = new CheesePizza();
    } else if (type === "greek") {
      pizza = new GreekPizza();
    } else if (type === "pepperoni") {
      pizza = new PepperoniPizza();
    }

    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();

    return pizza;
  }
}
```

从上面 `PizzaStore` 的实现可以看出，如果后续需要对披萨的类型进行增减，那就需要对 `orderPizza` 中对 Pizza 实例化的部分进行修改。这样的代码其实是违反了开闭原则的，没法对修改关闭。

上面提到的问题，可以使用“简单工厂”来解决这个问题。我们将创建 Pizza 的逻辑放到一个只操心如何创建 Pizza 的对象，这个对象我们称之为工厂：

```ts
abstract class Pizza {
  /** 准备操作 */
  prepare() {}
  /** 烘烤操作 */
  bake() {}
  /** 裁剪操作 */
  cut() {}
  /** 打包操作 */
  box() {}
}

class CheesePizza extends Pizza {}
class GreekPizza extends Pizza {}
class PepperoniPizza extends Pizza {}

class SimplePizzaFactory {
  createPizza(type: "cheese" | "greek" | "pepperoni") {
    let pizza!: Pizza;

    if (type === "cheese") {
      pizza = new CheesePizza();
    } else if (type === "greek") {
      pizza = new GreekPizza();
    } else if (type === "pepperoni") {
      pizza = new PepperoniPizza();
    }

    return pizza;
  }
}

class PizzaStore {
  factory: SimplePizzaFactory;
  constructor(factory: SimplePizzaFactory) {
    this.factory = factory;
  }

  orderPizza(type: "cheese" | "greek" | "pepperoni") {
    const pizza = this.factory.createPizza(type);

    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();

    return pizza;
  }
}
```

经过改造后，我们将 Pizza 的创建逻辑封装到 `SimplePizzaFactory` 中，并通过对象组合的方式将工厂类注入到 `PizzaStore` 中，这样后面有不同的 Pizza 简单工厂类就不需要更改 `PizzaStore` 中的逻辑了。
